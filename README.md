# Installing

To install this program simply clone this repository. Afterwards, copy and rename the config_file.example.py into config_file.py and adjust the values of the variables inside to the correct values for your system.

Finally, make sure that clingo is installed in your system.
https://github.com/potassco/clingo

# Produce nogoods

To produce nogoods use __produce_nogoods.py__. To run it needs some files(encoding, etc), an instance and an amount of nogoods to extract.

Sample call:

```
python produce_nogoods.py --files encodings/basic_encoding.lp encodings/assumption-solver.py --instance test-instances/blocks-11.lp --nogoods-limit 100
```

Additionally, pddl instances can be used instead of regular asp instances with the --pddl-instance option(if the instance has a .pddl extension the --instance options treats the instance as pddl). The program will try to find the domain file in the same folder of the instance or in the parent folder. A domain can also be manually given with the --pddl-domain option.

Sample call:

```
python produce_nogoods.py --files encodings/basic_encoding.lp encodings/assumption-solver.py --pddl-instance path/to/pddl/instance.pddl --nogoods-limit 100
```

For more options such as maximum extraction time use --help

The nogoods will be saved into a file called __conv_ng.lp__

## Validating nogoods
To make sure that the nogoods produced can always be generalized it is possible to validate them after their production.

### Validating with encoding
To validate nogoods use the option --validate-files. The value of the option must be a file(s) that can be used to validate them. E.g __validation-encoding/state_prover.lp__ when using basic_encoding.lp as the encoding.
This validation consists of individually validating each nogood using the instance, the validation encoding and the following program:
```
#const degree={deg}.
hypothesisConstraint({t}-degree) {constraint}
:- not hypothesisConstraint(1).
```
where {deg} is replaced by the degree of the nogood, {t} is replaced by the variable that represents time and {constraint} is replace by a string that represent the nogood as a contraint.

### Validating without encoding
Another validation option is to use the --validate-instance option. This validation option consist of adding the nogood to the original problem representation and checking that no stable model is invalid afterwards.

For this we use the provided encodings and instance as well as the following program:
```
error({t}) {constraint}
error :- error(_).
:- not error.
```
{t} is replaced by the variable that represents time and {constraint} is replace by a string that represent the nogood as a contraint.

# Consuming nogoods

To consume the nogoods generated by __produce_nogoods.py__ use the __consume_nogoods.py__ program. A file containing the output nogoods from a __produce_nogoods.py__ call has to be given as input with the --nogoods option aswell as some sort of scaling(explained below)

Sample call:

```
python consume_nogoods.py --files encodings/basic_encoding.lp encodings/assumption-solver.py test-instances/blocks-11.lp --nogoods conv_ng.lp --scaling 2,4,8 
```

Pddl instances are supported aswell when using the option --pddl-instance to pass them.

## Scaling

The nogoods are consumed based on a set scaling given with the --scaling-list or --scaling-exp option. 

The --scaling-list option is very straightforward. The value should just be a list of integers separated by a comma that indicate how many nogoods should be used in the run. For example: a scaling list of 2,4,8,16,32 will run 5 runs with each run having the amount of nogoods specified in the list. A special scaling of -1 signifies that __ALL__ nogoods will be used for that round.

The input for the --scaling-exp option has 3 values separated by a comma. The first value is the starting amount of nogoods. The second value is the increase factor. The third value is how many iterations to perform.

For example, a scaling of 8,2,5 will start by using 8 nogoods. The noogods used will be doubled after every iteration and there will be a total of 5 iterations. So, there will be 5 clingo calls where 8, 16, 32, 64 and 128 nogoods are consumed. 

Consuming nogoods will run a baseline call with 0 nogoods added unless the --no-base-run option is used.

## Configuration File

The configuration file contains information about the location of some important programs.

The first argument of the list FD_CALL should contain a path to the Fast Downward python script.

RUNSOLVER_PATH should contain the path to some runsolver binary call

PLASP should contain the path to the desired plasp translator